{"pages":[],"posts":[{"title":"设计模式笔记","text":"Spring中涉及的设计模式总结 简单工厂(非23种设计模式中的一种) 实现方式： BeanFactory。Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。 实质： 由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。 实现原理： bean容器的启动阶段： 读取bean的xml配置文件,将bean元素分别转换成一个BeanDefinition对象。 然后通过BeanDefinitionRegistry将这些bean注册到beanFactory中，保存在它的一个ConcurrentHashMap中。 将BeanDefinition注册到了beanFactory之后，在这里Spring为我们提供了一个扩展的切口，允许我们通过实现接口BeanFactoryPostProcessor 在此处来插入我们定义的代码。典型的例子就是：PropertyPlaceholderConfigurer，我们一般在配置数据库的dataSource时使用到的占位符的值，就是它注入进去的。 容器中bean的实例化阶段： 实例化阶段主要是通过反射或者CGLIB对bean进行实例化，在这个阶段Spring又给我们暴露了很多的扩展点： 各种的Aware接口 ，比如 BeanFactoryAware，对于实现了这些Aware接口的bean，在实例化bean时Spring会帮我们注入对应的BeanFactory的实例。 BeanPostProcessor接口 ，实现了BeanPostProcessor接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。 InitializingBean接口 ，实现了InitializingBean接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。 DisposableBean接口 ，实现了BeanPostProcessor接口的bean，在该bean死亡时Spring会帮我们调用接口中的方法。 设计意义： 松耦合。 可以将原来硬编码的依赖，通过Spring这个beanFactory这个工厂来注入依赖，也就是说原来只有依赖方和被依赖方，现在我们引入了第三方——spring这个beanFactory，由它来解决bean之间的依赖问题，达到了松耦合的效果. bean的额外处理。 通过Spring接口的暴露，在实例化bean的阶段我们可以进行一些额外的处理，这些额外的处理只需要让bean实现对应的接口即可，那么spring就会在bean的生命周期调用我们实现的接口来处理该bean。[非常重要] 工厂方法 实现方式： FactoryBean接口。 实现原理： 实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean() 调用获得该bean时，会自动调用该bean的getObject()方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。 例子： 典型的例子有spring与mybatis的结合。 代码示例： 123456&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:config/mybatis-config-masterxml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:config/mappers/master/*/xml&quot;/&gt;&lt;/bean&gt; 说明： 我们看上面该bean，因为实现了FactoryBean接口，所以返回的不是 SqlSessionFactoryBean 的实例，而是它的 SqlSessionFactoryBean.getObject() 的返回值。 单例模式 Spring依赖注入Bean实例默认是单例的。 Spring的依赖注入（包括lazy-init方式）都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean的创建。 分析getSingleton()方法 1234567891011121314151617181920212223242526272829303132public class Singleton() { public Object getSingleton(String beanName) { //参数true设置标识允许早期依赖 return getSingleton(beanName, true); } protected Object getSingleton(String beanName, boolean allowEarlyReference) { //检查缓存中是否存在实例 Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) { //如果为空，则锁定全局变量并进行处理。 synchronized (this.singletonObjects) { //如果此bean正在加载，则不处理 singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null &amp;&amp; allowEarlyReference) { //当某些方法需要提前初始化的时候则会调用addSingleFactory 方法将对应的ObjectFactory初始化策略存储在singletonFactories ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) { //调用预先设定的getObject方法 singletonObject = singletonFactory.getObject(); //记录在缓存中，earlySingletonObjects和singletonFactories互斥 this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); } } } } return (singletonObject != NULL_OBJECT ? singletonObject : null); }} getSingleton()过程图 ps：spring依赖注入时，使用了 双重判断加锁 的单例模式 123456graph TDs[[singletonObjects +getBeanName&lt;&gt;]] ==&gt;e[[earlySingletonObjects +getBeanName&lt;&gt;]] ==&gt;f[[singletonFactories +getObject&lt;&gt;]] ==&gt;创[[创建单例实例]] ===&gt;|remove|f创 ==&gt;|put|e 总结： 单例模式定义： 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 spring对单例的实现： spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为spring管理的是任意的java对象。 适配器模式 实现方式： SpringMVC中的适配器HandlerAdatper。 实现原理： HandlerAdatper根据Handler规则执行不同的Handler。 实现过程： DispatcherServlet根据HandlerMapping返回的handler，向HandlerAdatper发起请求，处理Handler。 HandlerAdapter根据规则找到对应的Handler并让其执行，执行完毕后Handler会向HandlerAdapter返回一个ModelAndView，最后由HandlerAdapter向DispatchServelet返回一个ModelAndView。 实现意义： HandlerAdatper使得Handler的扩展变得容易，只需要增加一个新的Handler和一个对应的HandlerAdapter即可。 因此Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类，让适配器代替controller执行相应的方法。这样在扩展Controller时，只需要增加一个适配器类就完成了SpringMVC的扩展了。 装饰器模式 实现方式： Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。 实质： 动态地给一个对象添加一些额外的职责。 就增加功能来说，Decorator模式相比生成子类更为灵活。 代理模式 实现方式： AOP底层，就是动态代理模式的实现。 动态代理：在内存中构建的，不需要手动编写代理类 静态代理：需要手工编写代理类，代理类引用被代理对象。 实现原理： 切面在应用运行的时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象创建动态的创建一个代理对象。SpringAOP就是以这种方式织入切面的。 织入：把切面应用到目标对象并创建新的代理对象的过程。 观察者模式 实现方式： spring的事件驱动模型使用的是 观察者模式 ，Spring中Observer模式常用的地方是listener的实现。 具体实现： 事件机制的实现需要三个部分,事件源,事件,事件监听器 (1) ApplicationEvent抽象类[事件] 继承自jdk的EventObject,所有的事件都需要继承ApplicationEvent,并且通过构造器参数source得到事件源. 该类的实现类ApplicationContextEvent表示ApplicationContext的容器事件. 代码： 12345678910111213public abstract class ApplicationEvent extends EventObject { private static final long serialVersionUID = 7099057708183571937L; private final long timestamp; public ApplicationEvent(Object source) { super(source); this.timestamp = System.currentTimeMillis(); } public final long getTimestamp() { return this.timestamp; }} (2)ApplicationListener接口[事件监听器] 继承自jdk的EventListener,所有的监听器都要实现这个接口。 这个接口只有一个onApplicationEvent()方法,该方法接受一个ApplicationEvent或其子类对象作为参数,在方法体中,可以通过不同对Event类的判断来进行相应的处理。 当事件触发时所有的监听器都会收到消息。 代码： 123public interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener { void onApplicationEvent(E event);} (3) ApplicationContext接口[事件源] ApplicationContext是spring中的全局容器，翻译过来是”应用上下文”。 实现了ApplicationEventPublisher接口。 职责：负责读取bean的配置文档,管理bean的加载,维护bean之间的依赖关系,可以说是负责bean的整个生命周期,再通俗一点就是我们平时所说的IOC容器。 代码： 123456789101112131415161718public interface ApplicationEventPublisher { void publishEvent(ApplicationEvent event);}public class EventPublisher implements ApplicationEventPublisher { public void publishEvent(ApplicationEvent event) { Assert.notNull(event, &quot;Event must not be null&quot;); if (logger.isTraceEnabled()) { logger.trace(&quot;Publishing event in &quot; + getDisplayName() + &quot;: &quot; + event); } getApplicationEventMulticaster().multicastEvent(event); if (this.parent != null) { this.parent.publishEvent(event); } }} (4)ApplicationEventMulticaster抽象类[事件源中publishEvent方法需要调用其方法getApplicationEventMulticaster] 属于事件广播器,它的作用是把ApplicationContext发布的Event广播给所有的监听器. 代码： 123456789101112131415161718public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext, DisposableBean { private ApplicationEventMulticaster applicationEventMulticaster; protected void registerListeners() { // Register statically specified listeners first. for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) { getApplicationEventMulticaster().addApplicationListener(listener); } // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let post-processors apply to them! String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false); for (String lisName : listenerBeanNames) { getApplicationEventMulticaster().addApplicationListenerBean(lisName); } }} 策略模式 实现方式： Spring框架的资源访问Resource接口。该接口提供了更强的资源访问能力，Spring 框架本身大量使用了 Resource 接口来访问底层资源。 Resource 接口介绍 source 接口是具体资源访问策略的抽象，也是所有资源访问类所实现的接口。 Resource 接口主要提供了如下几个方法: getInputStream()： 定位并打开资源，返回资源对应的输入流。每次调用都返回新的输入流。调用者必须负责关闭输入流。 exists()： 返回 Resource 所指向的资源是否存在。 isOpen()： 返回资源文件是否打开，如果资源文件不能多次读取，每次读取结束应该显式关闭，以防止资源泄漏。 getDescription()： 返回资源的描述信息，通常用于资源处理出错时输出该信息，通常是全限定文件名或实际 URL。 getFile： 返回资源对应的 File 对象。 getURL： 返回资源对应的 URL 对象。 最后两个方法通常无须使用，仅在通过简单方式访问无法实现时，Resource 提供传统的资源访问的功能。 Resource 接口本身没有提供访问任何底层资源的实现逻辑，针对不同的底层资源，Spring 将会提供不同的 Resource 实现类，不同的实现类负责不同的资源访问逻辑。 Spring 为 Resource 接口提供了如下实现类： UrlResource： 访问网络资源的实现类。 ClassPathResource： 访问类加载路径里资源的实现类。 FileSystemResource： 访问文件系统里资源的实现类。 ServletContextResource： 访问相对于 ServletContext 路径里的资源的实现类. InputStreamResource： 访问输入流资源的实现类。 ByteArrayResource： 访问字节数组资源的实现类。 这些 Resource 实现类，针对不同的的底层资源，提供了相应的资源访问逻辑，并提供便捷的包装，以利于客户端程序的资源访问。 模版方法模式 经典模板方法定义： 父类定义了骨架（调用哪些方法及顺序），某些特定方法由子类实现。 最大的好处：代码复用，减少重复代码。除了子类要实现的特定方法，其他方法及方法调用顺序都在父类中预先写好了。 所以父类模板方法中有两类方法： 共同的方法： 所有子类都会用到的代码 不同的方法： 子类要覆盖的方法，分为两种： 抽象方法：父类中的是抽象方法，子类必须覆盖 钩子方法：父类中是一个空方法，子类继承了默认也是空的 注：为什么叫钩子，子类可以通过这个钩子（方法），控制父类，因为这个钩子实际是父类的方法（空方法）！ Spring模板方法模式实质： 是模板方法模式和回调模式的结合，是Template Method不需要继承的另一种实现方式。Spring几乎所有的外接扩展都采用这种模式。 具体实现： JDBC的抽象和对Hibernate的集成，都采用了一种理念或者处理方式，那就是模板方法模式与相应的Callback接口相结合。 采用模板方法模式是为了以一种统一而集中的方式来处理资源的获取和释放，以JdbcTemplate为例: 12345678910111213141516171819public abstract class JdbcTemplate { public final Object execute(String sql) { Connection con = null; Statement stmt = null; try { con = getConnection(); stmt = con.createStatement(); Object retValue = executeWithStatement(stmt, sql); return retValue; } catch (SQLException e) { } finally { closeStatement(stmt); releaseConnection(con); } } protected abstract Object executeWithStatement(Statement stmt, String sql);} 引入回调原因： JdbcTemplate是抽象类，不能够独立使用，我们每次进行数据访问的时候都要给出一个相应的子类实现,这样肯定不方便，所以就引入了回调。 回调代码 123public interface StatementCallback { Object doWithStatement(Statement stmt);} 利用回调方法重写JdbcTemplate方法 1234567891011121314151617181920public class JdbcTemplate { public final Object execute(StatementCallback callback) { Connection con = null; Statement stmt = null; try { con = getConnection(); stmt = con.createStatement(); Object retValue = callback.doWithStatement(stmt); return retValue; } catch (SQLException e) { } finally { closeStatement(stmt); releaseConnection(con); } }}//其它方法定义... 为什么JdbcTemplate没有使用继承？ 因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？ 我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？ 那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。","link":"/2023/08/18/design-model/"},{"title":"Docker 笔记","text":"README 本篇主要记录Docker学习笔记 docker pull $image 12345678910111213141516docker pull mysql# Using default tag: latest# latest: Pulling from library/mysql# b193354265ba: Pull complete # 分层下载 联合文件系统# 14a15c0bb358: Already exists # 分层下载 联合文件系统 可以和其他镜像共用# 02da291ad1e4: Pull complete # 9a89a1d664ee: Pull complete # a24ae6513051: Pull complete # b85424247193: Pull complete # 9a240a3b3d51: Pull complete # 8bf57120f71f: Pull complete # c64090e82a0b: Pull complete # af7c7515d542: Pull complete # Digest: sha256:c0455ac041844b5e65cd08571387fa5b50ab2a6179557fd938298cab13acf0dd # 签名# Status: Downloaded newer image for mysql:latest# docker.io/library/mysql:latest #真实地址 等价 docker pull mysql 两种进入容器的方法 进入容器内部 开启一个新终端 1docker exec -it $container /bin/bash 进入容器内部 进入正在执行的容器终端 不开启新终端 1docker attach $container 拷贝文件 1docker cp $container:$path $path 拷贝容器内文件到主机 运行挂载容器卷 1docker run -it -v $name:/etc/nginx:ro nginx --volumes-from mysql 具名挂载：默认目录 /var/lib/docker/volumes/$name/_data 匿名挂载：不填$name: :ro readonly 只能容器外部修改 :rw readwrite --volumes-from 跟随挂载 例子可以实现多个mysql容器数据同步 docker inspect $container 信息 docker history $image 查看镜像历史构建步骤 Dockerfile 命令 说明 ADD 添加文件进去 COPY 添加文件进去 RUN 镜像构建时运行的命令 CMD 容器启动时运行的命令，会被外部参数替换 ENTRYPOINT 容器启动时运行的命令，可以追加 ENV 构建时设置环境变量 CMD 和 ENTRYPOINT 区别 两者都是设置某容器启动时要执行的命令 举例如下： 构建 centos 镜像，打印当前目录 123# DockerfileFROM centosCMD [&quot;ls&quot;,&quot;-a&quot;] 12docker build .docker run $container -l CMD 会报错，因为 ls -a 被替换成了 -l ENTRYPOINT 无报错，可以正常打印当前目录信息，因为 ls -a 被追加成了 ls -la Dockerfile 例子 12FROM centosCMD [&quot;ls&quot;,&quot;-a&quot;]","link":"/2023/08/18/docker/"},{"title":"Windows环境VM中安装Ubuntu 23.04","text":"准备镜像 https://mirrors.tuna.tsinghua.edu.cn/ ubuntu-23.04-desktop-amd64.iso 安装VM17 MC60H-DWHD5-H80U9-6V85M-8280D VM中安装Ubuntu https://blog.csdn.net/qyfx123456/article/details/130190155 12#（vm中复制粘贴用）sudo apt-get install open-vm-tools-desktop -y Ubuntu中安装Docker https://docs.docker.com/engine/install/ubuntu/ Ubuntu中安装JDK8 1sudo apt-get install openjdk-8-jdk Ubuntu中安装Redis 安装 https://developer.aliyun.com/article/764565 1sudo apt install redis-server 注释bind 12vim /etc/redis/redis.conf# bind 127.0.0.1 设置密码 12vim /etc/redis/redis.conf# requierpass 123 通过防火墙 1sudo ufw allow proto tcp from 192.168.58.1/24 to any port 6379 开机自启动 1sudo systemctl enable redis-server Ubuntu中安装MySQL 123456789101112131415sudo apt install mysql-server# 防火墙 allowsudo ufw allow mysqlsudo vim /etc/mysql/mysql.conf.d/mysqld.cnfbind-address 0.0.0.0# mysqlmysqluse mysql;set global validate_password.policy=0;set global validate_password.length=3;ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';update user set host = '%' where user='root';FLUSH PRIVILEGES;# restartsudo systemctl restart mysql Docker中安装Nacos 123456789vim Dokcerfile# DockerfileFROM nacos/nacos-server:latestEXPOSE 8848ENV MODE standaloneENV LANG en_US.UTF-8ENV LANGUAGE en_US.UTF-8ENV LC_ALL en_US.UTF-8CMD [&quot;nacos&quot;] 12# builddocker build -t nacos . 12# rundocker run --name nacos --restart=always -d -p 8848:8848 nacos 12# ufwsudo ufw allow proto tcp from 192.168.58.1/24 to any port 8848 12# curlcurl localhost:8848/nacos","link":"/2023/08/18/vm-ubuntu/"},{"title":"Windows 生成及配置 GitHub SSH","text":"README 本篇主要记录Windows环境，生成及配置非默认、具有别名的SSH keys。 id_ed25519.pub 这种以默认的名称命名的公钥文件，不需要额外配置即可自动识别。 github_olive.pub 这种自定义key的公钥文件，需要在ssh-agent中添加才可被识别。 Generate SSH 1234567cd C:\\Users\\olive\\.sshssh-keygen -t ed25519 -C &quot;&lt;your github email&gt;&quot;# Generating public/private ed25519 key pair.# Enter file in which to save the key (C:\\Users\\olive/.ssh/id_ed25519): github_olivels# 2023/08/16 15:43 411 github_olive# 2023/08/16 15:43 98 github_olive.pub Github 配置 SSH keys Setting -&gt; SSH and GPG keys -&gt; New SSH key 本地测试是否配置成功 12ssh -T &quot;git@github.com&quot;# git@github.com: Permission denied (publickey). 具体原因看README。 配置 Config 文件 ssh-agent &amp; ssh-add 我实践配置只在当前窗口生效， $ eval “$(ssh-agent -s)” Agent pid 555 ssh-add ~/.ssh/github_olive 所以目前选择配置 SSH Config 文件 config 文件位置及内容如下 12345678910cd C:\\Users\\olive\\.sshls# 2023/08/16 15:43 1 config# 2023/08/16 15:43 411 github_olive# 2023/08/16 15:43 98 github_olive.pubvim config# Host github.com# HostName github.com# PreferredAuthentications publickey# IdentityFile ~/.ssh/github_olive 再次测试是否授权 12ssh -T &quot;git@github.com&quot;# Hi olive! You've successfully authenticated, but GitHub does not provide shell access.","link":"/2023/08/16/github-ssh/"},{"title":"通过 GitHub 搭建个人博客 Hexo","text":"README https://hexo.io/zh-cn/ 安装之前确认好要安装的 Hexo 版本所对应的 Node 最低需求 例如 Hexo 6.3.0 最低支持 node 14 构建 https://www.npmjs.com/package/hexo/v/6.3.0 安装 Hexo 1npm install -g hexo-cli 建站 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 本地运行 123hexo cleanhexo ghexo s 访问 localhost:4000 部署 部署到 GitHub Pages 修改 _config.yml 替换添加如下 1234deploy: type: git repo: git@github.com:$username/$username.github.io.git branch: master 1npm install hexo-deployer-git --save 最后执行三连。 123hexo cleanhexo ghexo d 访问 $username.github.io 仓库名称需要设置成 $username.github.io 的格式","link":"/2023/08/16/hexo-init/"},{"title":"Spring AOP 笔记","text":"README AOP 的使用，基本上都会涉及到自定义注解，一种非常常见的组合，就是自定义注解+AOP。 在开发中，AOP最大的作用就是重复代码简化。 首先，自定义一个注解。 定义 AOP 切面，在切面中，定义切点和通知，切点，也就是方法的拦截规则，我们可以按照注解来拦截，也就是某一个带有自定义注解的方法，将被我拦截下来。 拦截下来之后，前置通知、后置通知、异常通知、返回通知还是环绕通知。 幂等性处理 Token 机制 去重表 利用 Redis setnx 设置状态字段 上锁 自定义注解。 自定义切点。 定义环绕通知，在环绕通知中，先通过上述五种思路中的任意一种，对方法执行的幂等性进行判断。 接口限流 推荐成熟方案 Alibaba Sentinel 思路大致如下： 自定义注解。 在需要进行限流的接口方法上添加自定义注解，同时还可以设置一些限流的参数，例如时间窗口值、流量大小等。 自定义切点，拦截到方法之后，在环绕通知中，可以通过 Redis 插件 redis-cell、通过漏斗算法去处理限流。 日志处理 AOP经典例子 多数据源处理 自定义多数据源： 从 Spring2.0.1 中引入了 AbstractRoutingDataSource 类，该类充当了 DataSource 的路由中介，它能够在运行时, 根据某种 key 值来动态切换到真正的 DataSource 上。 大致的用法是提前准备好各种数据源，存入到一个 Map 中，Map 的 key 就是这个数据源的名字，Map 的 value 就是这个具体的数据源，然后再把这个 Map 配置到 AbstractRoutingDataSource 中，之后，每次执行数据库查询的时候，拿一个 key 出来，AbstractRoutingDataSource 会找到具体的数据源去执行这次数据库操作。 思路大致如下： 自定义注解。 在需要切换数据源的方法上添加自定义注解。 自定义切点，拦截到方法之后，在环绕通知中，根据注解中的配置，重新设置要执行的数据源。 方法权限处理 推荐成熟方案 Spring Security 思路大致如下： 自定义注解。 在需要进行校验的方法上添加自定义注解。 自定义切点，拦截到方法之后，在环绕通知中，根据注解中的配置，查询处理权限。 事务处理 Spring 提供注解，对于声明式事务，直接用现成的注解，本质上也是 AOP。","link":"/2023/08/18/spring-aop/"}],"tags":[{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"VM","slug":"VM","link":"/tags/VM/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"SSH","slug":"SSH","link":"/tags/SSH/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Spring AOP","slug":"Spring-AOP","link":"/tags/Spring-AOP/"}],"categories":[{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/categories/Ubuntu/"},{"name":"SSH","slug":"SSH","link":"/categories/SSH/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"VM","slug":"Ubuntu/VM","link":"/categories/Ubuntu/VM/"},{"name":"Spring AOP","slug":"Spring-AOP","link":"/categories/Spring-AOP/"}]}